<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=UTF-8">
    <!--<link rel="stylesheet" href=" CONF_STYLE_PREFIX priv.css " type="text/css">-->
    <!--<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">-->
    <title>Выражения фильтра посылок</title>
  </head>
  <body>
    <h1>Выражения фильтра посылок</h1>

    <h2>Содержание</h2>
<ol>
<li><a href="#datatypes">Типы данных</a></li>
<li><a href="#statuses">Статусы посылок</a></li>
<li><a href="#conversions">Преобразования типов</a></li>
<li><a href="#primitives">Примитивы доступа к базе посылок</a></li>
<li><a href="#otherprimitives">Другие примитивы</a></li>
<li><a href="#priority">Приоритеты операций</a></li>
<li><a href="#operations">Операции</a></li>
<li><a href="#examples">Примеры</a></li>
</ol>

<p>Выражение фильтра посылок позволяет задать условия, которым
должны удовлетворять параметры посылок, чтобы быть показанными в
списке посылок, генерируемом CGI-программами <tt>new-master</tt> и
<tt>new-judge</tt>. Выражение фильтра должно иметь тип <tt>bool</tt>, а в
противном случае генерируется ошибка.</p>

<p>
При генерации страницы привилегированного пользователя в
CGI-программах <tt>new-judge</tt> или <tt>new-master</tt> выражение фильтра
используется следующим образом. Выражение фильтра применяется ко
всем записям в базе посылок, и если на некоторой записи
результат вычисления выражения равен <tt>true</tt>, то данная запись
помечается как удовлетворяющая фильтру. Если при вычислении
выражения фильтра хотя бы для одной посылки возникла ошибка,
отображается информация об ошибке, а не результаты фильтрации.
Если при вычислении выражения фильтра для всех записей
завершилось успешно, из записей, удовлетворяющих выражению
фильтра, отображаются записи в соответствии с заданным номером
первой и номером последней записей.
</p>

<p>
Выражение фильтра посылок имеет Си-подобный синтаксис.
Пробельные символы, разделяющие элементы выражения,
игнорируются. В именах типов и полей регистр символов является
значимым.
</p>

<h2>Типы данных</h2>

<a name="datatypes"/>

<p>
Выражение фильтра посылок строго типизировано. Выражение может
состоять из операций над значениями следующих типов:
</p>

<ul>
<li><b>Булевский.</b>
Булевский тип обозначается <tt>bool</tt>. Литералы булевского типа
обозначаются <tt>false</tt> и <tt>true</tt> соответственно.</li>
<li><b>Целый.</b>
Целый тип обозначается <tt>int</tt>. В текущей реализации целый тип
является 32-битным знаковым типом
(диапазон значений от -2147483648 до 2147483647).
Литералы целого типа могут записываться в восьмеричной,
десятичной и шестнадцатеричной системах счисления как в языке Си.
Знак &laquo;минус&raquo; перед числом
не является частью числа, а рассматривается как унарная операция
изменения знака.</li>
<li><b>Строковой.</b>
Строковой тип обозначается <tt>string</tt>.
Литералы строкового типа записываются либо в кавычках (<tt>&quot;</tt>),
либо в апострофах (<tt>'</tt>).
Литералы первого вида не могут содержать внутри себя
символ кавычки, а литералы второго вида &mdash; символ апострофа.</li>
<li><b>Календарный.</b>
Календарный тип обозначается <tt>date_t</tt> и предназначен для записи
астрономического времени. Литералов календарного типа не
существует. Астрономическое время при расчётах представляется в
формате POSIX, то есть как количество секунд, прошедших с 1
января 1970 года.</li>
<li><b>Длительностный.</b>
Длительностный тип обозначается <tt>dur_t</tt> и предназначен для
записи длительностей. При расчётах длительностный тип
рассматривается как целый тип, и все длительности представляются
в секундах. Литералов длительностного типа не существует.</li>
<li><b>Размерный.</b>
Размерный тип обозначается <tt>size_t</tt> и предназначен для
представления размеров объектов. Литералов размерного типа не
существует. При расчётах размерный тип рассматривается как
беззнаковый целый тип.</li>
<li><b>Статусный.</b>
Статусный тип обозначается <tt>result_t</tt> и предназначен для
представления статуса посылки. Статусный тип &mdash; это
перечислимый тип, состоящий из литералов <tt>OK</tt>, <tt>CE</tt>, <tt>RT</tt>,
<tt>TL</tt>, <tt>PE</tt>, <tt>WA</tt>, <tt>CF</tt>,
<tt>PT</tt>, <tt>AC</tt>, <tt>IG</tt>, <tt>DQ</tt>,
<tt>PD</tt>, <tt>ML</tt>, <tt>SE</tt>,
<tt>RU</tt>, <tt>CD</tt>, <tt>CG</tt>, <tt>AV</tt>, <tt>EM</tt>,
<tt>VS</tt>, <tt>VT</tt>.</li>
<li><b>Контрольный.</b>
Контрольный тип обозначается <tt>hash_t</tt> и предназначен для
представления значений контрольной суммы SHA1. Литералов
контрольного типа не существует.</li>
<li><b>Адресный.</b>
Адресный тип обозначается <tt>ip_t</tt> и предназначен для
представления IP-адресов. Литералов адресного типа не
существует.
</ul>

<h2>Статусы посылок</h2>

<a name="statuses" />

<table>
  <tr>
    <td><tt>OK</tt></td>
    <td>OK</td>
  </tr>
  <tr>
    <td><tt>CE</tt></td>
    <td>Compilation error</td>
  </tr>
  <tr>
    <td><tt>RT</tt></td>
    <td>Run-time error</td>
  </tr>
  <tr>
    <td><tt>TL</tt></td>
    <td>Time-limit exceeded</td>
  </tr>
  <tr>
    <td><tt>PE</tt></td>
    <td>Presentation error</td>
  </tr>
  <tr>
    <td><tt>WA</tt></td>
    <td>Wrong answer</td>
  </tr>
  <tr>
    <td><tt>CF</tt></td>
    <td>Check failed (internal error)</td>
  </tr>
  <tr>
    <td><tt>PT</tt></td>
    <td>Partial solution</td>
  </tr>
  <tr>
    <td><tt>AC</tt></td>
    <td>Accepted</td>
  </tr>
  <tr>
    <td><tt>IG</tt></td>
    <td>Ignored</td>
  </tr>
  <tr>
    <td><tt>DQ</tt></td>
    <td>Disqualified</td>
  </tr>
  <tr>
    <td><tt>PD</tt></td>
    <td>Pending</td>
  </tr>
  <tr>
    <td><tt>ML</tt></td>
    <td>Memory-limit error</td>
  </tr>
  <tr>
    <td><tt>SE</tt></td>
    <td>Security violation</td>
  </tr>
  <tr>
    <td><tt>SY</tt></td>
    <td>Synchronization error</td>
  </tr>
  <tr>
    <td><tt>SV</tt></td>
    <td>Style violation</td>
  </tr>
  <tr>
    <td><tt>WT</tt></td>
    <td>Wall time (real time) limit exceeded</td>
  </tr>
  <tr>
    <td><tt>PR</tt></td>
    <td>Pending review</td>
  </tr>
  <tr>
    <td><tt>SM</tt></td>
    <td>Summoned for defence</td>
  </tr>
  <tr>
    <td><tt>RJ</tt></td>
    <td>Rejected</td>
  </tr>
  <tr>
    <td><tt>RU</tt></td>
    <td>Running (in testing queue or being tested)</td>
  </tr>
  <tr>
    <td><tt>CD</tt></td>
    <td>Compiled (but not yet running)</td>
  </tr>
  <tr>
    <td><tt>CG</tt></td>
    <td>Compiling (in compile queue or being compiled)</td>
  </tr>
  <tr>
    <td><tt>AV</tt></td>
    <td>Available for testing</td>
  </tr>
  <tr>
    <td><tt>EM</tt></td>
    <td>Empty record</td>
  </tr>
  <tr>
    <td><tt>VS</tt></td>
    <td>Virtual start</td>
  </tr>
  <tr>
    <td><tt>VT</tt></td>
    <td>Virtual stop</td>
  </tr>
</table>

<h2>Преобразования типов</h2>

<a name="conversions"/>

<p>
Выражение фильтра посылок строго типизировано, но для
преобразований значений одного типа в значения другого типа
могут использоваться операции преобразования типа. Операция
преобразования типа записывается в стиле Си++, то есть следующим
образом:
<pre>
type-cast-op = type-name "(" expr ")"
</pre>
Здесь <tt>type-name</tt> &mdash; имя типа, одно из перечисленных выше
<tt>bool</tt>, <tt>int</tt>, <tt>string</tt>, <tt>date_t</tt>, <tt>dur_t</tt>,
<tt>size_t</tt>, <tt>result_t</tt>, <tt>hash_t</tt>, <tt>ip_t</tt>. Не все
возможные преобразования типов допустимы. Возможные комбинации
исходного типа и целевого типа показаны в таблице ниже.
В строках таблицы записан исходный
тип, а в столбцах таблицы &mdash; целевой тип.
</p>

<table border="1">
  <tr>
    <th border="1">&nbsp;</th>
    <th border="1"><tt>bool</tt></th>
    <th border="1"><tt>int</tt></th>
    <th border="1"><tt>string</tt></th>
    <th border="1"><tt>date_t</tt></th>
    <th border="1"><tt>dur_t</tt></th>
    <th border="1"><tt>size_t</tt></th>
    <th border="1"><tt>result_t</tt></th>
    <th border="1"><tt>hash_t</tt></th>
    <th border="1"><tt>ip_t</tt></th>
  </tr>
  <tr><td><tt>bool</tt>      </td><td> + </td><td> + </td><td> + </td><td>   </td><td>   </td><td>   </td><td>   </td><td>   </td><td>   </td></tr>
<tr><td><tt>int</tt>       </td><td> + </td><td> + </td><td> + </td><td> + </td><td> + </td><td> + </td><td> + </td><td>   </td><td> + </td></tr>
<tr><td><tt>string</tt>    </td><td> + </td><td> + </td><td> + </td><td> + </td><td> + </td><td> + </td><td> + </td><td> + </td><td> + </td></tr>
<tr><td><tt>date_t</tt>   </td><td> + </td><td> + </td><td> + </td><td> + </td><td>   </td><td>   </td><td>   </td><td>   </td><td>   </td></tr>
<tr><td><tt>dur_t</tt>    </td><td> + </td><td> + </td><td> + </td><td>   </td><td> + </td><td>   </td><td>   </td><td>   </td><td>   </td></tr>
<tr><td><tt>size_t</tt>   </td><td> + </td><td> + </td><td> + </td><td>   </td><td>   </td><td> + </td><td>   </td><td>   </td><td>   </td></tr>
<tr><td><tt>result_t</tt> </td><td> + </td><td> + </td><td> + </td><td>   </td><td>   </td><td>   </td><td> + </td><td>   </td><td>   </td></tr>
<tr><td><tt>hash_t</tt>   </td><td> + </td><td> + </td><td> + </td><td>   </td><td>   </td><td>   </td><td>   </td><td> + </td><td>   </td></tr>
<tr><td><tt>ip_t</tt>     </td><td> + </td><td> + </td><td> + </td><td>   </td><td>   </td><td>   </td><td>   </td><td>   </td><td> + </td></tr>
</table>

<p>
Рассмотрим подробнее каждое нетривиальное преобразование типов.
</p>

<ul>
  <li><tt><b>int</b></tt> к <tt><b>bool</b></tt>.<br/>
Даёт результат <tt>false</tt>, если приводимое целое значение равно
нулю, и <tt>true</tt> иначе.</li>
  <li><tt><b>string</b></tt> к <tt><b>bool</b></tt>.<br/>
Даёт результат <tt>false</tt>, если значение строки равно <tt>false</tt>
(без учёта регистра), и результат <tt>true</tt>, если значение строки
равно <tt>true</tt> (без учёта регистра). Если значение строки не
может быть распознано как булевский литерал, генерируется ошибка
вычисления выражения.</li>
  <li><tt><b>date_t</b></tt> к <tt><b>bool</b></tt>.<br/>
Даёт результат <tt>false</tt>, если значение астрономического времени
во внутреннем формате равно нулю, и <tt>true</tt> иначе. На практике
астрономическое время может быть равно нулю (то есть 00:00:00 1 января
1970 года по Гринвичу), когда значение соответствующей
переменной или поля не установлено.</li>
  <li><tt><b>dur_t</b></tt> к <tt><b>bool</b></tt>.<br/>
Даёт результат <tt>false</tt>, если значение длительности равно 0
секундам, и <tt>true</tt> иначе.</li>
  <li><tt><b>size_t</b></tt> к <tt><b>bool</b></tt>.<br/>
Даёт результат <tt>false</tt>, если значение размера равно 0 байтам,
и <tt>true</tt> иначе.</li>
  <li><tt><b>result_t</b></tt> к <tt><b>bool</b></tt>.<br/>
Даёт результат <tt>true</tt>, если значение статуса равно <tt>OK</tt>, и
<tt>false</tt> иначе. Обратите внимание на отличие семантики этой
операции от других операций преобразования в булевский тип.</li>
  <li><tt><b>hash_t</b></tt> к <tt><b>bool</b></tt>.<br/>
Даёт результат <tt>false</tt>, если значение хэш-кода равно нулю, то
есть все 20 байт хэш-кода равны нулю, и <tt>true</tt> иначе. Нулевой
хэш-код означает, что значение соответствующего поля или
переменной не установлено.</li>
  <li><tt><b>ip_t</b></tt> к <tt><b>bool</b></tt>.<br/>
Даёт результат <tt>false</tt>, если значение IP-адреса равно нулю, то
есть все 4 байта IP-адреса нулевые, и <tt>true</tt> иначе. Нулевой
IP-адрес означает, то значение соответствующего поля или
переменной не установлено.</li>
  <li><tt><b>bool</b></tt> к <tt><b>int</b></tt>.<br/>
Булевское значение <tt>false</tt> преобразуется в целое значение 0,
а булевское значение <tt>true</tt> &mdash; в целое значение 1.</li>
  <li><tt><b>string</b></tt> к <tt><b>int</b></tt>.<br/>
Строка рассматривается как запись числа в восьмеричной,
десятичной или шестнадцатеричной нотации (в синтаксисе Си),
возможно со знаком. Если число записано корректно и при переводе
в 32-битный знаковый тип не возникает переполнения, результатом
операции является соответствующее число. В противном случае
генерируется ошибка.</li>
  <li><tt><b>date_t</b></tt> к <tt><b>int</b></tt>.<br/>
Поскольку в настоящее время внутреннее представление типа
<tt>date_t</tt> &mdash; это 32-битное знаковое число, то значением
такого преобразования типов будет внутреннее представление
астрономического времени.</li>
  <li><tt><b>dur_t</b></tt> к <tt><b>int</b></tt>.<br/>
Поскольку в настоящее время внутреннее представление типа
<tt>dur_t</tt> &mdash; это 32-битное знаковое число, то значением
такого преобразования типов будет внутреннее представление
промежутка времени, то есть число секунд в нём.</li>
  <li><tt><b>size_t</b></tt> к <tt><b>int</b></tt>.<br/>
В настоящее время тип <tt>size_t</tt> &mdash; это 32-битный беззнаковый
целый тип. Если значение размера при переводе из беззнакового
представления в знаковое не вызывает переполнение (то есть
значение размера не превосходит 2<sup>31</sup>-1), выполняется
преобразование из беззнакового типа в знаковый без изменения
представления числа. В противном случае генерируется ошибка.</li>
  <li><tt><b>result_t</b></tt> к <tt><b>int</b></tt>.<br/>
Результатом такого преобразования является числовое значение,
соответствующее коду статуса.</li>
  <li><tt><b>hash_t</b></tt> к <tt><b>int</b></tt>.<br/>
Результатом такого преобразования является целое значение,
составленное из первых 4 байтов хэш-кода. Предполагается, что
байты в числе записываются в порядке от младшего к старшему
(litte-endian).</li>
  <li><tt><b>ip_t</b></tt> к <tt><b>int</b></tt>.<br/>
Поскольку IP-адрес (IPv4) состоит из 4 байт, эти 4 байта
рассматриваются как целое число со знаком, записанное в порядке
байт от старшего к младшему.</li>
  <li><tt><b>bool</b></tt> к <tt><b>string</b></tt>.<br/>
Значение <tt>false</tt> преобразовывается в строку <tt>false</tt>, а
значение <tt>true</tt> &mdash; в строку <tt>true</tt>.</li>
  <li><tt><b>int</b></tt> к <tt><b>string</b></tt>.<br/>
Целое значение преобразуется в строку, содержащую запись
десятичного целого числа со знаком.</li>
  <li><tt><b>date_t</b></tt> к <tt><b>string</b></tt>.<br/>
Астрономическое время преобразуется в строку вида
<pre>
YYYY/MM/DD hh:mm:ss
</pre>
Здесь <tt>YYYY</tt> &mdash; год, <tt>MM</tt> &mdash; месяц (от 01 до 12),
<tt>DD</tt> &mdash; день месяца (от 01 до 31), <tt>hh</tt> &mdash; час (от 00 до
23), <tt>mm</tt> &mdash; минута (от 00 до 59), <tt>ss</tt> &mdash; секунда (от 00 до 59).</li>
  <li><tt><b>dur_t</b></tt> к <tt><b>string</b></tt>.<br/>
Продолжительность преобразуется в строку вида
<pre>
#h:mm:ss
</pre>
Здесь <tt>#</tt> &mdash; знак продолжительности (для положительной
продолжительности знак не выводится, а для отрицательной
печатается знак <tt>-</tt>), <tt>h</tt> &mdash; число полных часов, <tt>mm</tt> &mdash;
число минут в последнем неполном часе (от 00 до 59), <tt>ss</tt> &mdash;
число секунд в последней неполной минуте (от 00 до 59).</li>
  <li><tt><b>size_t</b></tt> к <tt><b>string</b></tt>.<br/>
Значение размера преобразуется в строку, содержащую запись
десятичного целого числа без знака.</li>
  <li><tt><b>result_t</b></tt> к <tt><b>string</b></tt>.<br/>
Значение статуса преобразовывается в строку в соответствии с
таблицей (столбец &laquo;Выражение фильтра&raquo;).
Например, значение статуса <tt>RUN_TIME_ERR</tt> преобразуется в строке
<tt>RT</tt>.</li>
  <li><tt><b>hash_t</b></tt> к <tt><b>string</b></tt>.<br/>
Значение хэш-кода распечатывается в виде 40 шестнадцатеричных
цифр (по два символа на байт от первого байта хэш-кода к
последнему). В качестве шестнадцатеричных цифр используются
десятичные цифры и строчные латинские буквы от <tt>a</tt> до <tt>f</tt>.</li>
  <li><tt><b>ip_t</b></tt> к <tt><b>string</b></tt>.<br/>
IP-адрес переводится в строку, содержащую запись адреса в
стандартной точечной нотации (то есть 4 десятичных числа от 0 до
255, разделённые точками).</li>
  <li><tt><b>int</b></tt> к <tt><b>date_t</b></tt>.<br/>
Поскольку тип <tt>date_t</tt> представляется как 32-битное целое
знаковое число, при данном преобразование целое значение
рассматривается как внутреннее представление астрономического
времени.</li>
  <li><tt><b>string</b></tt> к <tt><b>date_t</b></tt>.<br/>
Для преобразования строки к типу астрономического времени строка
должна иметь значение, удовлетворяющее следующему формату
<pre>
Y / M / D [ h [ : m [ : s ] ] ]
</pre>
Здесь запись <tt>[ X ]</tt>, означает, что элемент <tt>X</tt> может
отсутствовать, символы <tt>/</tt> и <tt>:</tt> представляют сами себя, а
<tt>Y</tt>, <tt>M</tt>, <tt>D</tt>, <tt>h</tt>, <tt>m</tt>, <tt>s</tt> &mdash; это целые
десятичные числа. Они могут отделяться от <tt>/</tt> и <tt>:</tt>
произвольным количеством пробельных символов. <tt>Y</tt> &mdash; это год,
который должен находиться в интервале от 1900 до 2100, <tt>M</tt> &mdash;
порядковый номер месяца (от 1 до 12), <tt>D</tt> &mdash; порядковый номер
дня в месяце (от 1 до 31), <tt>h</tt> &mdash; час суток (от 0 до 23),
<tt>m</tt> &mdash; минута (от 0 до 59), <tt>s</tt> &mdash; секунда (от 0 до 59).
Если часы, минуты или секунды опущены, они полагаются равными
0. Кроме того, дата должна находится в диапазоне представимых
в POSIX дат (то есть примерно от 1906 до 2038 года). Если
все условия выполняются, строковая запись астрономического
времени конвертируется во внутреннее представление, а в
противном случае генерируется ошибка.</li>
  <li><tt><b>int</b></tt> к <tt><b>dur_t</b></tt>.<br/>
Поскольку тип <tt>dur_t</tt> представляется как 32-битное целое
знаковое число, при данном преобразование целое значение
рассматривается как внутреннее представление промежутка
времени.</li>
  <li><tt><b>string</b></tt> к <tt><b>dur_t</b></tt>.<br/>
Для преобразования строки к длительностному значению строка
должна иметь значение, удовлетворяющее следующему формату.
<pre>
[ # ] h [ : m [ : s ] ]
</pre>
Здесь запись <tt>[ X ]</tt>, означает, что элемент <tt>X</tt> может
отсутствовать. <tt>#</tt> &mdash; это знак <tt>+</tt> или <tt>-</tt>.
<tt>h</tt>, <tt>m</tt> и <tt>s</tt> &mdash; положительные целые числа. <tt>h</tt> &mdash; количество
часов, <tt>m</tt> &mdash; количество минут (от 0 до 59), <tt>s</tt> &mdash;
количество секунд (от 0 до 59). Если минуты или секунды опущены,
их число полагается равным 0. После перевода в секунды
длительность должна находится в диапазоне целых чисел,
представимых 32-битными знаковыми числами. Если все условия
выполняются, то строковая запись длительностного значения
конвертируется во внутреннее представление, а в противном случае
генерируется ошибка.</li>
  <li><tt><b>int</b></tt> к <tt><b>size_t</b></tt>.<br/>
Поскольку <tt>int</tt> &mdash; это 32-битный знаковый тип, а <tt>size_t</tt>
&mdash; 32-битный беззнаковый тип, неотрицательные значения типа
<tt>int</tt> преобразовываются в значения типа <tt>size_t</tt>
тривиально. При попытке преобразования отрицательных чисел
генерируется ошибка.</li>
  <li><tt><b>string</b></tt> к <tt><b>size_t</b></tt>.<br/>
Строка должна содержать запись беззнакового целого числа в
восьмеричной, десятичной или шестнадцатеричной системе (как в
языке Си). Число должно быть представимо 32-битным беззнаковым
числом. Если эти условия выполняются, происходит преобразование
строки в значение типа <tt>size_t</tt>, а в противном случае
генерируется ошибка.</li>
  <li><tt><b>int</b></tt> к <tt><b>result_t</b></tt>.<br/>
Целое значение должно быть равным одному из значений статусов,
перечисленных в таблице. В этом случае
выполняется преобразование типа, а иначе генерируется ошибка.</li>
  <li><tt><b>string</b></tt> к <tt><b>result_t</b></tt>.<br/>
Строка должна быть равна одной из строк, перечисленных в таблице
в столбце &laquo;Выражение фильтра&raquo;. В этом
случае выполняется преобразование, а иначе генерируется ошибка.</li>
  <li><tt><b>string</b></tt> к <tt><b>hash_t</b></tt>.<br/>
Строка должна содержать 40 шестнадцатеричных цифр (буквы от
<tt>a</tt> до <tt>f</tt> могут быть как заглавными, так и строчными).
Пробельные символы в начале и конце строки игнорируются. 40
шестнадцатеричных цифр конвертируются в 20-байтное значение
хэш-кода. Предполагается, что порядок байт в слове &mdash; от
младшего к старшему (little-endian).</li>
  <li><tt><b>int</b></tt> к <tt><b>ip_t</b></tt>.<br/>
Поскольку значения типа <tt><b>ip_t</b></tt> представляются 32-битными
числами, преобразование из типа <tt>int</tt> не изменяет
представления данных, то есть целое число рассматривается как
запись IP-адреса во внутреннем представлении.</li>
  <li><tt><b>string</b></tt> к <tt><b>ip_t</b></tt>.<br/>
Для преобразования строки к типу <tt>ip_t</tt> строка должна иметь
значение, удовлетворяющее следующему шаблону.
<pre>
A.B.C.D
</pre>
Здесь <tt>.</tt> &mdash; это символ &laquo;точка&raquo;, а <tt>A</tt>, <tt>B</tt>, <tt>C</tt> и <tt>D</tt> &mdash; целые беззнаковые числа от 0 до 255. Если эти условия
выполняются строка конвертируется в соответствующее значение
типа <tt>ip_t</tt>, а в противном случае генерируется ошибка.
</ul>

<h2>Примитивы доступа к базе посылок</h2>

<p>
Текущей посылкой назовём обрабатываемую при вычислении выражения
фильтра посылку. На основании результата вычисления выражения
фильтра определяется, может ли быть отображена текущая посылка.
</p>

<p>
Примитивы доступа к базе посылок позволяют получать значения
полей как текущей посылки, так и любой другой посылки с заданным
номером. Примитивы имеют следующий общий вид:
<pre>
f [ ( expr ) ]
</pre>
Здесь в квадратных скобках <tt>[</tt> и <tt>]</tt> записана необязательная
часть. Круглые скобки <tt>(</tt> и <tt>)</tt> обозначают сами себя. \V{f}
&mdash; это имя примитива, а <tt>expr</tt> &mdash; это выражение целого
типа. Если выражение в скобках не задано, то берётся значение
поля, соответствующего имени примитива <tt>f</tt>, текущей посылки.
Если выражение в скобках не является выражением целого типа,
генерируется ошибка. В противном случае выражение вычисляется, и
пусть при вычислении выражения ошибок не возникло, а <i>n</i> &mdash;
результат вычисления выражения.
</p>

<p>
Если <i>n</i> &lt; 0, то <i>n</i> задаёт номер посылки начиная от последней,
то есть <i>n</i>' = <i>N</i> + <i>n$</i>, где <i>N</i> &mdash; общее количество посылок в базе посылок в данный момент. В противном случае предполагаем,
что <i>n</i> задаёт номер посылки начиная от нулевой, то есть <i>n</i>' = <i>n</i>.
Если теперь <i>n</i>' &lt; 0 или <i>n</i>' &ge; <i>N</i>, то генерируется
ошибка вычисления выражения фильтра. Если же <i>n</i>' удовлетворяет
ограничениям, берётся значение поля, соответствующего имени
примитива <tt>f</tt>, в посылке с номером <i>n</i>'.
</p>

<p>
Примитивы доступа к базе посылок перечислены в таблице.
</p>

<table border="1">
  <tr>
    <th>Имя примитива</th>
    <th>Тип значения</th>
    <th>Описание</th>
  </tr>
  <tr>
    <td><tt>id</tt> или <tt>run_id</tt></td>
    <td><tt>int</tt></td>
    <td>Номер посылки (значение поля <tt>run_id</tt>). Посылки нумеруются от 0.</td>
  </tr>
  <tr>
    <td><tt>time</tt></td>
    <td><tt>time_t</tt></td>
    <td>Астрономическое время получения посылки сервером (значение поля <tt>time</tt>)</td>
  </tr>
  <tr>
    <td><tt>dur</tt></td>
    <td><tt>dur_t</tt></td>
    <td>Длительность времени от начала турнира до получения посылки сервером (то есть разность между временем получения посылки и моментом начала турнира)</td>
  </tr>
  <tr>
    <td><tt>size</tt></td>
    <td><tt>size_t</tt></td>
    <td>Размер исходного текста программы в байтах (значение поля <tt>size</tt>).</td>
  </tr>
  <tr>
    <td><tt>hash</tt></td>
    <td><tt>hash_t</tt></td>
    <td>Хэш-код текста программы (значение поля <tt>sha1</tt>).</td>
  </tr>
  <tr>
    <td><tt>uuid</tt></td>
    <td><tt>string</tt></td>
    <td>Уникальный идентификатор посылки (значение поля <tt>run_uuid</tt>).</td>
  </tr>
  <tr>
    <td><tt>ip</tt></td>
    <td><tt>ip_t</tt></td>
    <td>IP-адрес клиента, на котором работает веб-браузер, и с которого была получена данная посылка (значение поля <tt>ip</tt>).</td>
  </tr>
  <tr>
    <td><tt>uid</tt> или <tt>user_id</tt></td>
    <td><tt>int</tt></td>
    <td>Идентификатор пользователя, от имени которого была выполнена данная посылка (значение поля <tt>user_id</tt>). Идентификатор пользователя всегда больше нуля.</td>
  </tr>
  <tr>
    <td><tt>login</tt></td>
    <td><tt>string</tt></td>
    <td>Регистрационное имя (login) пользователя, от имени которого была выполнена данная посылка.</td>
  </tr>
  <tr>
    <td><tt>name</tt></td>
    <td><tt>string</tt></td>
    <td>Имя (name) пользователя, от имени которого была выполнена данная посылка.</td>
  </tr>
  <tr>
    <td><tt>group</tt></td>
    <td><tt>string</tt></td>
    <td>Группа первого участника пользователя, от имени которого
      была выполнена данная посылка.</td>
  </tr>
  <tr>
    <td><tt>cypher</tt></td>
    <td><tt>string</tt></td>
    <td>Шифр пользователя, от имени которого была выполнена данная посылка.</td>
  </tr>
  <tr>
    <td><tt>lang</tt> или <tt>lang_id</tt></td>
    <td><tt>string</tt></td>
    <td>Короткое имя языка программирования, который был использован в данной посылке. Идентификатор языка программирования находится в поле <tt>lang_id</tt> записи базы посылок, а короткое имя языка программирования берётся из значения конфигурационной переменной <tt>short_name</tt> секции описания языка программирования файла конфигурации турнира <tt>serve.cfg</tt>.</td>
  </tr>
  <tr>
    <td><tt>arch</tt></td>
    <td><tt>string</tt></td>
    <td>Архитектура языка программирования</td>
  </tr>
  <tr>
    <td><tt>prob</tt> или <tt>prob_id</tt></td>
    <td><tt>string</tt></td>
    <td>Короткое имя задачи, решаемой в данной посылке. Идентификатор задачи находится в поле <tt>prob_id</tt> записи базы посылок, а короткое имя задачи берётся из значения конфигурационной переменной <tt>short_name</tt> секции описания задачи файла конфигурации турнира <tt>serve.cfg</tt>.</td>
  </tr>
  <tr>
    <td><tt>result</tt> или <tt>status</tt></td>
    <td><tt>result_t</tt></td>
    <td>Статус посылки (значение поля <tt>status</tt>).</td>
  </tr>
  <tr>
    <td><tt>score</tt></td>
    <td><tt>int</tt></td>
    <td>Балл за данную посылку без учёта штрафных баллов за посылки (значение поля <tt>score</tt>).</td>
  </tr>
  <tr>
    <td><tt>test</tt></td>
    <td><tt>int</tt></td>
    <td>Минимальный номер теста, на котором программа дала неверный результат, или количество успешно пройденных тестов в зависимости от типа турнира.</td>
  </tr>
  <tr>
    <td><tt>imported</tt></td>
    <td><tt>bool</tt></td>
    <td>Флаг импортированной посылки (значение поля <tt>is_imported</tt>).</td>
  </tr>
  <tr>
    <td><tt>hidden</tt></td>
    <td><tt>bool</tt></td>
    <td>Флаг скрытой посылки (значение поля <tt>is_hidden</tt>).</td>
  </tr>
  <tr>
    <td><tt>readonly</tt></td>
    <td><tt>bool</tt></td>
    <td>Флаг неизменяемой посылки (значение поля <tt>is_readonly</tt>).</td>
  </tr>
  <tr>
    <td><tt>variant</tt></td>
    <td><tt>int</tt></td>
    <td>Действительный вариант. Если для вариантной задачи номер варианта, хранящийся в базе посылок (значение поля <tt>variant</tt>), равен 0, используется номер варианта, установленный в файле карты вариантов, устанавливаемом глобальной конфигурационной переменной  <tt>variant_map_file</tt> конфигурационного файла описания турнира <tt>serve.cfg</tt>.</td>
  </tr>
  <tr>
    <td><tt>rawvariant</tt></td>
    <td><tt>int</tt></td>
    <td>Хранимый вариант задачи в посылке (значение поля <tt>variant</tt>).</td>
  </tr>
  <tr>
    <td><tt>userinvisible</tt></td>
    <td><tt>bool</tt></td>
    <td><tt>true</tt>, если посылка выполнена пользователем, у которого установлен статус invisible.</td>
  </tr>
  <tr>
    <td><tt>userbanned</tt></td>
    <td><tt>bool</tt></td>
    <td><tt>true</tt>, если посылка выполнена пользователем, у которого установлен статус banned.</td>
  </tr>
  <tr>
    <td><tt>userlocked</tt></td>
    <td><tt>bool</tt></td>
    <td><tt>true</tt>, если посылка выполнена пользователем, у которого установлен статус locked.</td>
  </tr>
  <tr>
    <td><tt>userincomplete</tt></td>
    <td><tt>bool</tt></td>
    <td><tt>true</tt>, если посылка выполнена пользователем, у которого установлен статус incomplete.</td>
  </tr>
  <tr>
    <td><tt>userdisqualified</tt></td>
    <td><tt>bool</tt></td>
    <td><tt>true</tt>, если посылка выполнена пользователем, у которого установлен статус disqualified.</td>
  </tr>
  <tr>
    <td><tt>latest</tt></td>
    <td><tt>bool</tt></td>
    <td><tt>true</tt>, если посылка имеет статус OK, Partial solution или Accepted for testing и после нее нет посылок того же пользователя по той же задаче с этими статусами. Предикат может применяться в турнирах типа Olympiad для отбора посылок для полной проверки.</td>
  </tr>
  <tr>
    <td><tt>afterok</tt></td>
    <td><tt>bool</tt></td>
    <td><tt>true</tt>, если у этого пользователя уже была посылка по этой же задаче, которая получила статус OK</td>
  </tr>
  <tr>
    <td><tt>judge_id</tt></td>
    <td><tt>int</tt></td>
    <td>Идентификационный номер запроса на тестирование (поле <tt>judge_id</tt>). Идентификационный номер изменяется в диапазоне от 1 до 65535. Число 0 означает отсутствие идентификационного номера.</td>
  </tr>
  <tr>
    <td><tt>inusergroup(GRP)</tt></td>
    <td><tt>bool</tt></td>
    <td><tt>true</tt>, если этот пользователь принадлежит указанной группе пользователей. Название группы пользователей записывается как строка. Пример: <tt>inusergroup(&quot;Group1&quot;)</tt>.</td>
  </tr>
</table>

<h2>Другие примитивы</h2>

<a name="otherprimitives"/>

<p>
В выражении фильтра можно использовать примитивы для получения
текущего времени, текущей продолжительности турнира и некоторые
другие. Все такие примитивы рассмотрены в данном разделе.
Примитивы имеют следующий общий вид:
<pre>
p
</pre>
где <tt>p</tt> &mdash; это имя примитива. Примитивы перечислены в таблице.
</p>

<table border="1">
  <tr>
    <th>Имя примитива</th>
    <th>Тип значения</th>
    <th>Описание</th>
  </tr>
  <tr>
    <td><tt>now</tt></td>
    <td><tt>time_t</tt></td>
    <td>Текущее астрономическое время.</td>
  </tr>
  <tr>
    <td><tt>start</tt></td>
    <td><tt>time_t</tt></td>
    <td>Астрономическое время начала турнира.</td>
  </tr>
  <tr>
    <td><tt>finish</tt></td>
    <td><tt>time_t</tt></td>
    <td>Астрономическое время завершения турнира.</td>
  </tr>
  <tr>
    <td><tt>total</tt></td>
    <td><tt>int</tt></td>
    <td>Общее количество записей в базе посылок.</td>
</table>

<h2>Приоритеты операций</h2>

<a name="priority"/>

<p>
В данном разделе перечислены все операции, допустимые в
выражении фильтра. Операции перечисляются в порядке убывания
приоритета от наиболее приоритетных к наименее приоритетным.
Приоритеты операций совпадают с приоритетами операций в языках Си, Си++, Java.
</p>

<ol>
<li>
Все литеральные значения (булевские, целые, строковые,
статусные), все примитивы, операции преобразования типа,
операция записи выражения в скобках <tt>(</tt><i>expr</i><tt>)</tt>.</li>
<li>
Префиксные операции <tt>~</tt>, <tt>!</tt>, <tt>-</tt>, <tt>+</tt>. Префиксные
операции читаются справа налево.</li>
<li>
Мультипликативные операции <tt>*</tt>, <tt>/</tt>, <tt>%</tt>.
Мультипликативные операции левоассоциативны, то есть читаются
слева направо.</li>
<li>
Аддитивные операции <tt>+</tt>, <tt>-</tt>. Они читаются также слева
направо.</li>
<li>
Операции сдвига <tt>&lt;&lt;</tt> и <tt>&gt;&gt;</tt>. Читаются слева направо.
</li>
<li>
Операции отношений <tt>==</tt>, <tt>!=</tt>, <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>&lt;=</tt>, <tt>&gt;=</tt>, <tt>~=</tt>. Читаются слева направо.</li>
<li>
Операция побитового &laquo;и&raquo; <tt>&amp;</tt>. Читается слева направо.</li>
<li>
Операция побитового исключающего &laquo;или&raquo; <tt>^</tt>. Читается слева направо.</li>
<li>
Операция побитового &laquo;или&raquo; <tt>|</tt>. Читается слева направо.</li>
<li>
Операция логического &laquo;и&raquo; <tt>&amp;&amp;</tt> или <tt>and</tt> (эти формы записи синонимичны). Читается слева направо.</li>
<li>Операция логического &laquo;или&raquo; <tt>||</tt> или <tt>or</tt> (эти формы записи синонимичны). Читается слева направо.</li>
</ol>

<p>
Далее рассмотрим все перечисленные операции.
</p>

<h2>Операции</h2>

<a name="operations"/>

<h3>Операция побитового отрицания <tt>~</tt></h3>

<p>
Операция применима только к значению типа <tt>int</tt>. Результат
операции &mdash; значение типа <tt>int</tt>, получаемое побитовым
отрицанием первого значения.
</p>

<h3>Операция логического отрицания <tt>!</tt></h3>

<p>
Операция применима только к значению типа <tt>bool</tt>. Результат
операции &mdash; значение типа <tt>bool</tt>, получаемое логическим
отрицанием исходного значения.
</p>

<h3>Операция смены знака <tt>-</tt></h3>

<p>
Унарная операция смены знака применима только к значению типа
<tt>int</tt>. Результат операции &mdash; значение типа <tt>int</tt> с
противоположным знаком. Если результат операции не представим
в типе <tt>int</tt> (то есть 32-битным знаковым числом),
диагностируется ошибка переполнения.
</p>

<h3>&laquo;Пустая&raquo; операция <tt>+</tt></h3>

<p>
Данная операция применима только к значению типа <tt>int</tt> и даёт
результат типа <tt>int</tt>. Результирующее значение равно
исходному.
</p>

<h3>Операция умножения <tt>*</tt></h3>

<p>
Для операции умножения возможны следующие комбинации типов
операндов.
</p>

<ul>
<li>
Оба аргумента имеют тип <tt>int</tt>. Результат имеет тип <tt>int</tt>.
Если результат не представим в типе <tt>int</tt> диагностируется
переполнение.</li>
<li>
Один аргумент имеет тип <tt>int</tt>, а другой &mdash; <tt>dur_t</tt>. В этом
случае результат имеет тип <tt>dur_t</tt>. Если произведение
аргументов не представимо в типе <tt>dur_t</tt>, диагностируется
переполнение.</li>
<li>
Один аргумент имеет тип <tt>int</tt>, а другой &mdash; <tt>size_t</tt>.
Значение аргумента целого типа в данном случае должно быть
больше нуля. Произведение имеет тип <tt>size_t</tt>. Если значение
произведения не представимо в типе <tt>size_t</tt>, диагностируется
переполнение.</li>
</ul>

<h3>Операция целочисленного деления <tt>/</tt></h3>

<p>
Для операции целочисленного деления возможны следующие
комбинации типов операндов. Если делитель равен нулю,
диагностируется ошибка деления на ноль. Если результат операции
не представим в типе результата, диагностируется ошибка
переполнения. Например, при делении минимального значения типа
<tt>int</tt>, равного &minus;2<sup>31</sup> на &minus;1 получается значение
2<sup>31</sup>, не представимое в типе <tt>int</tt>.
</p>

<ul>
<li>
Оба аргумента имеют тип <tt>int</tt>. Тогда результат имеет тип
<tt>int</tt>.</li>
<li>
Оба аргумента имеют тип <tt>dur_t</tt>. Тогда результат имеет тип
<tt>int</tt>.</li>
<li>
Оба аргумента имеют тип <tt>size_t</tt>. Тогда результат имеет тип
<tt>int</tt>.</li>
<li>
Делимое имеет тип <tt>dur_t</tt>, а делитель &mdash; тип <tt>int</tt>. Тогда
результат имеет тип <tt>dur_t</tt>.</li>
<li>
Делимое имеет тип <tt>size_t</tt>, а делитель &mdash; тип <tt>int</tt>.
Результат в этом случае имеет тип <tt>size_t</tt>. Делитель должен
быть положителен.</li>
</ul>

<h3>Операция взятия остатка от деления <tt>%</tt></h3>

<p>
Операция взятия остатка поддерживает несколько комбинаций типов
аргументов. Если делитель равен нулю, диагностируется ошибка
деления на ноль. Если тип делителя &mdash; какой-либо знаковый тип
(например, <tt>int</tt> или <tt>dur_t</tt>), и делитель отрицателен,
диагностируется ошибка неверного аргумента. Если результат
операции не представим в типе результата, диагностируется ошибка
переполнения. Допустимые комбинации типов операндов перечислены
ниже.
</p>
 
<ul>
<li>
Оба аргумента имеют тип <tt>int</tt>. Тогда результат имеет тип
<tt>int</tt>.</li>
<li>
Оба аргумента имеют тип <tt>dur_t</tt>. Тогда результат имеет тип
<tt>int</tt>.</li>
<li>
Оба аргумента имеют тип <tt>size_t</tt>. Тогда результат имеет тип
<tt>int</tt>.</li>
<li>
Делимое имеет тип <tt>dur_t</tt>, а делитель &mdash; тип <tt>int</tt>. Тогда
результат имеет тип <tt>dur_t</tt>.</li>
<li>
Делимое имеет тип <tt>size_t</tt>, а делитель &mdash; тип <tt>int</tt>.
Результат в этом случае имеет тип <tt>size_t</tt>.</li>
</ul>

<h3>Операция сложения <tt>+</tt></h3>

<p>
Операция сложения применима ко многим комбинациям типов
операндов. В любом случае, если результат операции не представим
в типе результата, генерируется ошибка переполнения. Допустимые
комбинации типов операндов перечислены ниже.
</p>

<ul>
<li>
Оба аргумента имеют тип <tt>int</tt>. Результат также имеет тип
<tt>int</tt>.</li>
<li>
Оба аргумента имеют тип <tt>string</tt>. Результат имеет тип
<tt>string</tt> и равен конкатенации двух строк.</li>
<li>
Оба аргумента имеют тип <tt>dur_t</tt>. Результат также имеет тип
<tt>dur_t</tt>.</li>
<li>
Оба аргумента имеют тип <tt>size_t</tt>. Результат также имеет тип
<tt>size_t</tt>.</li>
<li>
Один аргумент имеет тип <tt>int</tt>, а другой &mdash; <tt>time_t</tt>.
Результат имеет тип <tt>time_t</tt>.</li>
<li>
Один аргумент имеет тип <tt>int</tt>, а другой &mdash; <tt>dur_t</tt>.
Результат имеет тип <tt>dur_t</tt>.</li>
<li>
Один аргумент имеет тип <tt>time_t</tt>, а другой &mdash; <tt>dur_t</tt>.
Результат имеет тип <tt>time_t</tt>.</li>
</ul>

<h3>Операция вычитания <tt>-</tt></h3>

<p>
Операция вычитания применима ко многим комбинациям типов
операндов. В любом случае, если результат операции не представим
в типе результата, генерируется ошибка переполнения. Допустимые
комбинации типов операндов перечислены ниже.
</p>

<ul>
<li>
Оба аргумента операции имеют тип <tt>int</tt>. Результат также имеет
тип <tt>int</tt>.</li>
<li>
Первый аргумент операции имеет тип <tt>int</tt>, а второй &mdash;
<tt>dur_t</tt>. Результат операции имеет тип <tt>dur_t</tt>.</li>
<li>
Первый аргумент операции имеет тип <tt>time_t</tt>, а второй &mdash;
<tt>int</tt>. Результат операции имеет тип <tt>time_t</tt>.</li>
<li>
Оба аргумента операции имеют тип <tt>time_t</tt>. В этом случае
результат имеет тип <tt>dur_t</tt>.</li>
<li>
Первый аргумент операции имеет тип <tt>time_t</tt>, а второй &mdash;
<tt>dur_t</tt>. Результат имеет тип <tt>time_t</tt>.</li>
<li>
Первый аргумент имеет тип <tt>dur_t</tt>, а второй &mdash; <tt>int</tt>.
Результат имеет тип <tt>dur_t</tt>.</li>
<li>
Оба аргумента операции имеют тип <tt>dur_t</tt>. В этом случае
результат имеет тип <tt>dur_t</tt>.</li>
<li>
Первый аргумент операции имеет тип <tt>size_t</tt>, а второй &mdash;
<tt>int</tt>. Тогда результат имеет тип <tt>size_t</tt>.</li>
<li>
Оба аргумента операции имеют тип <tt>size_t</tt>. В этом случае
результат имеет тип <tt>int</tt>.</li>
</ul>

<h3>Операции сдвига <tt>&lt;&lt;</tt> и <tt>&gt;&gt;</tt></h3>

<p>
Операции побитового сдвига влево <tt>&lt;&lt;</tt> и побитового сдвига
вправо <tt>&gt;&gt;</tt> применимы только к операндам типа <tt>int</tt>.
Результат операции имеет тип <tt>int</tt>. Второй аргумент операции
(количество бит сдвига) должен находиться в отрезке от 0 до 32
включительно. Если это условие не выполняется, генерируется
ошибка недопустимого аргумента операции. Сдвиг вправо
выполняется как побитовый сдвиг, то есть на место старших
разрядов числа помещаются нулевые биты. Переполнения при сдвиге
влево не диагностируется.
</p>

<h3>Операции отношения <tt>==</tt> и <tt>!=</tt></h3>

<p>
Операции проверки на равенство или неравенство применимы ко всем
типам данных. Оба аргумента должны иметь один и тот же тип.
Неявных преобразований типа не производится. Результат операции
имеет тип <tt>bool</tt>.
</p>

<h3>Операции отношения <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>&lt;=</tt>, <tt>&gt;=</tt></h3>

<p>
Данные операции применимы ко всем типам данных, кроме
<tt>result_t</tt>, <tt>hash_t</tt> и <tt>ip_t</tt>. Оба аргумента операции
должны иметь один и тот же тип данных. Результат операции имеет
тип <tt>bool</tt>.
</p>

<h3>Сопоставление с регулярным выражением <tt>~=</tt></h3>

<p>
Данная операция применима к двум строкам. Первая строка проверяется
на соответствие регулярному выражению, записанному во второй строке.
</p> 

<h3>Побитовые операции <tt>^</tt>, <tt>&amp;</tt>, <tt>|</tt></h3>

<p>
Побитовые операции применимы только к аргументам типа <tt>int</tt> и
в результате дают значение типа <tt>int</tt>.
</p>

<h3>Логические операции <tt>&amp;&amp;</tt> и <tt>||</tt></h3>

Логические операции применимы только к аргументам типа <tt>bool</tt>
и дают в результате значение типа <tt>bool</tt>. Как и в языке Си
значение второго аргумента операции не вычисляется, если
значение всего выражение известно.

<h2>Примеры</h2>

<a name="examples"/>

<ul>
<li>
<p>Показать посылки на языке <tt>gcc</tt>:</p>
<pre>
lang == "gcc"
</pre>
</li>
<li>
<p>Показать посылки по задаче <tt>A</tt>:</p>
<pre>
prob == "A"
</pre>
</li>
<li>
<p>Показать успешные посылки пользователя с логином <tt>serge</tt>:</p>
<pre>
login == "serge" &amp;&amp; status == OK
</pre>
</li>
</ul>

  </body>
</html>
